\documentclass{../tex/report}
\usepackage{setspace} % Setting line spacing
\usepackage{ulem} % Underline
\usepackage{caption} % Captioning figures
\usepackage{subcaption} % Subfigures
\usepackage{geometry} % Page layout
\usepackage{multicol} % Columned pages
\usepackage{array,etoolbox}
\usepackage{fancyhdr}
\usepackage{enumitem}
\usepackage[toc,page]{appendix}

% Page layout (margins, size, line spacing)
\geometry{letterpaper, left=1in, right=1in, bottom=1in, top=1in}
\setstretch{1.5}

% Headers
\pagestyle{fancy}
\lhead{I\textsuperscript{2}CIP - Design Report}
\rhead{PeaPod Technologies Inc.}

\begin{document}

\begin{titlepage}
    \begin{center}
        \vspace*{1.2cm}

        \textbf{\large{I\textsuperscript{2}CIP: Inter-Integrated Circuit Intra-networking Protocols}}

        \vspace{0.5cm}

        Design Report for a Hardware Design Specification for a Bus-Switched Intra-Network of Hot-Swap Modules of I\textsuperscript{2}C Targets and a Software Library of Intra-Network Communications Protocols for Rapid Implementation of Plug-and-Play Embedded Systems\\

        \vfill
        \textbf{Jayden Lefebvre - Founder \& CEO, Lead Engineer}\\
        Northumberland County, ON, Canada\\
        \vspace{.75cm}
        Primary Contact Email: \uline{contact@peapodtech.com}
        \vspace{1.25cm}

        Revision 1.0\\
        PeaPod Technologies Inc.\\
        November 2025

    \end{center}
\end{titlepage}

\thispagestyle{plain}

\tableofcontents
\newpage

\section{Design Abstract}\label{sec:abstract}
\setstretch{1.25}

% Please provide a brief summary description of the proposed technology. The abstract may answer some of the following questions: What is your proposed solution? What is novel and innovative about your proposed solution?

\hspace{24pt} The Intra-Integrated Circuit Intra-networking Protocols (I\textsuperscript{2}CIP) is a hardware design specification and communications protocols suite that enables hot-swappable, plug-and-play modular components for embedded systems. By leveraging existing I\textsuperscript{2}C components and enhancing them with a bus-switching architecture and dynamic communication protocols, I\textsuperscript{2}CIP allows for rapid prototyping and deployment of embedded systems with minimal configuration. Through this approach, I\textsuperscript{2}CIP aims to revolutionize the way embedded systems are designed and implemented, providing a flexible and scalable solution for developers and engineers.

\input{../tex/Specification.tex}

\hspace{24pt}It is advantageous to view a collection of devices on an I2C bus as an intra-network, analogous to the Internet, under certain conditions:

\begin{itemize}
    \item \textbf{Dynamic Routing}: \textit{Device reachability is subject to change.} This enables physical “plug-and-play” functionality.
    \item \textbf{Modularity}: \textit{Devices can be added to the network as physical collections.} This enables lifecycle management for physical collections of devices, and informs dynamic routing.
\end{itemize}

\hspace{24pt}In order to achieve an intra-network of I2C devices, we propose a suite of protocols built on top of I2C which together form the I2C Intranet Protocol, along with a compatible hardware specification.

\clearpage

\input{../tex/OSI.tex}

\clearpage

\section{Design Description}\label{sec:description}

% Please provide a more fulsome description of your technology. Your description needs to include information about what the technology is, what it does, how it functions, and how the stakeholders will interact with it. Be sure to also provide any descriptions of major hardware components and processes in relation to your technology.

\hspace{24pt} The I\textsuperscript{2}CIP technology is designed to facilitate seamless communication and interoperability between various I\textsuperscript{2}C devices in a modular embedded system environment. It achieves this by defining a set of hardware and software standards that enable hot-swapping of components, dynamic routing of data, and efficient management of device resources.

\input{../tex/Extension.tex}

\clearpage

\subsection{Hardware Specification}

\begin{itemize}
    \item \textbf{Electrical Isolator}: Prevents ground loops and protects sensitive components (\textbf{ISO1540}).
    \item \textbf{Level Shifters}: Allows communication between devices operating at different voltage levels.
    \item \textbf{Modules}: A physical collection of one or more I\textsuperscript{2}C devices connected to a common switch, including one SPRT EEPROM and the switch itself.
    \begin{itemize}
        \item \textbf{Switching Multiplexer} (MUX): A bus-switching multiplexer (\textbf{TCA9548A}). Eight possible MUX addresses (0x70-0x77) enables the instantiation of up to 8 modules per I\textsuperscript{2}C bus.
        \item \textbf{SPRT EEPROM}: A non-volatile memory device (\textbf{24LC32}) located on MUX bus 0 at default address 0x50. Stores a Static Partial Routing Table (SPRT) encoding intra-network location information for all devices on one switch's subnetworks.
        \item \textbf{Stuck-Bus Buffer}: A buffer that holds the I\textsuperscript{2}C bus state during module hot-swapping (\textbf{TCA4307}).
    \end{itemize}
\end{itemize}

\begin{figure}[h!]
\centering
    \includegraphics[width=0.8\textwidth]{../assets/module.png}
    \caption{I\textsuperscript{2}CIP Hardware Architecture Diagram}
    \label{fig:module}
\end{figure}

\clearpage

\subsection{Software Protocols}

\begin{itemize}
    \item \textbf{Fully-Qualified Addressing} (FQA): Enables unique identification of each device in the network. Encodes I\textsuperscript{2}C bus (3 bits; MSB 0-2), module number (3 bits; MSB 3-5), multiplexer bus (3 bits; MSB 6-8), and device address (7 bits; MSB 9-15) into a single 16-bit address.
    \item \textbf{Quality-of-Service Protocol} (QSP): Pings devices prior to and after any transmission, including multiplexers. Ensures transmission integrity and device availability using acknowledgments and retries with timeouts. Provides error level feedback to the Dynamic Routing Protocol (DRP).
    \item \textbf{Bus Switching Protocol} (BSP): Multiplexer control protocol that manages switching between multiple I\textsuperscript{2}C buses on a single module.
    \item \textbf{Device Lookup Protocol} (DLP): Enables groups of device FQAs to be looked up by ID.
    \item \textbf{Reverse Device Lookup Protocol} (RDLP): Enables devices' IDs to be looked up by their FQA.
    \item \textbf{Intra-network Discovery Protocol} (IDP): Reads SPRT EEPROMs to build two parallel working maps of the intra-network topology: a hash table for DLP and a binary tree for RDLP.
    \item \textbf{Dynamic Routing Protocol} (DRP): Utilizes the working maps generated by IDP and the error level feedback from QSP to inform routing decisions for data transmissions; i.e. if a module is unreachable, DRP will remove the module's devices from the working maps.
\end{itemize}

\clearpage

\section{Design Operations}\label{sec:operations}

% Please describe the basic operations concept of the technology. In your response, describe assumptions required of operation.

\subsection{Device Drivers}


% Device drivers
\hspace{24pt} For each type of device connected to an I\textsuperscript{2}CIP network, a corresponding device driver must be implemented within the host system's software stack. These drivers are responsible for managing communication with their respective devices, interpreting data, and providing a standardized interface for higher-level applications. These classes inherit from a common \texttt{Device} base class (which contains the \textbf{FQA} data and implements the \textbf{QSP} and \textbf{BSP} protocols during communications subroutines) as well as inheriting from either a \texttt{InputInterface} or \texttt{OutputInterface} (or \texttt{IOInterface}) abstract class, depending on the device's functionality. The \texttt{Interface} classes provide a templated set of methods for caching data read from input devices and writing data to output devices, while standardizing argument and return passing across all device drivers. The template parameter schema \texttt{<G, A, S, B>} represents the input buffer type (`G' for ``get''), input argument type (`A'), output buffer type (`S' for ``set''), and output argument type (`B'), respectively.

\hspace{24pt} For example, the \texttt{EEPROM} class (the device driver for the 24LC32 IC) inherits from the \texttt{Device} base class and the \texttt{IOInterface} abstract class, with template parameters \texttt{<char*, uint16\_t, char*, uint16\_t>}. In this order, these template parameters represent the input buffer type (character array), input argument (read length), output buffer type (character array), and output argument (write length), respectively.

\subsection{State Management}

\hspace{24pt} The fundamental building block of abstraction in I\textsuperscript{2}CIP state management is the \texttt{DeviceGroup} class, which represents a collection of I\textsuperscript{2}C devices of identical type. Each \texttt{DeviceGroup} contains an array of device driver instances, a factory (function pointer) for instantiating new devices, a handler (function pointer) for parsing JSON arguments into device-specific argument structures, and a cleanup (function pointer) for releasing those argument structures. The function pointers are passed to the \texttt{DeviceGroup} constructor from each device driver class, which defines them as static methods. This is achieved through a templated static factory method in the \texttt{DeviceGroup} class which takes one template parameter (the device driver class type) and returns a pointer to a newly instantiated \texttt{DeviceGroup} of that type.

\hspace{24pt} Rather than managing \texttt{DeviceGroup} instances directly, they are grouped together within a higher-level \texttt{Module} class, which represents a physical I\textsuperscript{2}CIP module. Each \texttt{Module} instance contains an hash table of \texttt{DeviceGroup} instances (by ID), implementing \textbf{DLP}. A single global-scope binary search tree is maintained by all \texttt{Module} instances, implementing \textbf{RDLP}.

\clearpage

\subsection{Modular Networking}

\hspace{24pt} The \texttt{Module} class is the primary abstraction for managing I\textsuperscript{2}CIP modules and devices within the host system's software stack. It defines three call operators: one taking an FQA and one taking a device ID, each updating a device's internal state based on the provided arguments, and one with no arguments that performs a module self-test that attempts to ping the MUX and rediscover the SPRT EEPROM. The method \texttt{discoverEEPROM} attempts to ping the SPRT EEPROM, adds it to the module's internal hash table of \texttt{DeviceGroup} instances (as well as the global binary search tree), and calls \texttt{parseEEPROMContents} (see below).

\hspace{24pt} The \texttt{Module} class is a virtual class, with several virtual methods that must be implemented in a derived class. These methods include:

\begin{itemize}
\item \texttt{protected deviceGroupFactory}, which takes a device ID and returns a pointer to a newly instantiated \texttt{DeviceGroup} of the corresponding type (or \texttt{nullptr} if the ID is unrecognized) - allows the user to link custom device drivers into the I\textsuperscript{2}CIP framework.
\item \texttt{public parseEEPROMContents}, which takes the contents of the SPRT EEPROM - for example, implementing \textbf{IDP} (as defined in the \texttt{JSONModule} derived class).
\item \texttt{public handleCommand} and \texttt{handleConfig}, which take \texttt{JSONObject} instances representing commands and configuration data, respectively - allows the user to define custom commands and configuration options for their specific module implementation.
\end{itemize}

\clearpage

\subsection{Static Partial Routing Table}

\hspace{24pt} The Static Partial Routing Table (SPRT) is a critical component of the I\textsuperscript{2}CIP technology, serving as a non-volatile memory storage for intra-network location information of all devices connected to a module's switch. Each module contains one SPRT EEPROM that holds the FQAs and IDs of its connected devices, allowing for efficient device discovery and routing within the network. The SPRT contents are UTF-8 encoded JSON, structured as an array of objects representing each multiplexer bus:

\begin{verbatim}
// Example SPRT JSON Contents
[
    // Array of MUX buses
    {
        // MUX bus 0
        "24LC32" : [ 80 ],    // Decimal encoding of device address 0x50
        "SHT31" : [ 68, 69 ], // Two SHT31 devices on MUX bus 0, 0x44 and 0x45
        "MCP23017" : [ 32 ],  // Another example device, 0x20
        // etc.
    },
    // Up to MUX bus 7
    { },
    {
        "24LC32" : [ 80, 81 ], // E.g. two more different EEPROM devices on MUX bus 2
    },
    { }, { }, { }, { }, { }
]
\end{verbatim}

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.7\textwidth]{../assets/example.png}
    \caption{Graphical Representation of Example SPRT Module}
    \label{fig:example}
\end{figure}

\clearpage

\subsection{User Interaction}

\begin{itemize}
    \item \textbf{MUX API}: Users can control multiplexers through a dedicated static API:
    \begin{itemize}
        \item \texttt{pingMUX}: Attempts to communicate (ACK) with a specified MUX (wire \& module number OR FQA).
        \item \texttt{setBus}: Pings and switches a specified MUX to a specified MUX bus (wire \& module number \& MUX bus OR FQA).
        \item \texttt{resetBus}: Pings and resets a specified MUX to deselect all MUX busses (wire \& module number OR FQA).
    \end{itemize}
    \item \textbf{Device API}: Users interact with I\textsuperscript{2}CIP devices through the instance API:
    \begin{itemize}
        \item \texttt{ping} and \texttt{pingTimeout}: Sets MUX bus and attempts to communicate (ACK) with the device (with optional timeout retries).
        \item \texttt{writeByte} and \texttt{write}: Sets MUX bus and writes one or more bytes (\texttt{uint8\_t} OR \texttt{uint8\_t*} with \texttt{size\_t}) to the device.
        \item \texttt{writeRegister}: Sets MUX bus and writes one or more bytes (\texttt{uint8\_t} OR \texttt{uint8\_t*} with \texttt{size\_t}) to a specified device register. Register size is specified as either 8-bit or 16-bit using argument overloading (\texttt{uint8\_t} OR \texttt{uint16\_t}).
        \item \texttt{readByte} and \texttt{readWord} and \texttt{read}: Sets MUX bus and requests one or more bytes (\texttt{uint8\_t} OR \texttt{uint16\_t} OR \texttt{uint8\_t*} with \texttt{size\_t}) from the device. Note: for \texttt{read} the \texttt{size\_t} argument is passed by reference, the actual number of bytes read is returned through this argument.
        \item \texttt{readRegisterByte} and \texttt{readRegisterWord} and \texttt{readRegister}: Sets MUX bus and requests one or more bytes (\texttt{uint8\_t} OR \texttt{uint8\_t*} with \texttt{size\_t}) from a specified device register. Register size is specified as either 8-bit or 16-bit using argument overloading (\texttt{uint8\_t} OR \texttt{uint16\_t}). Note: for \texttt{readRegister} the \texttt{size\_t} argument is passed by reference, the actual number of bytes read is returned through this argument.
    \end{itemize}
    \clearpage
    \item \textbf{Module API}: Users manage I\textsuperscript{2}CIP modules through the instance API:
    \begin{itemize}
        \item \texttt{parseEEPROMContents}: Virtual. Ideally, implements \textbf{IDP} by parsing the contents of the SPRT EEPROM and populating the module's internal hash table of \texttt{DeviceGroup} instances (as well as the global binary search tree).
        \item \texttt{discoverEEPROM}: Attempts to ping and rediscover the SPRT EEPROM on the module. Note: within EEPROM discovery, \texttt{parseEEPROMContents} is the only supported way to add devices to the module.
        \item Self-Test \texttt{operator()}: Performs a module self-test that attempts to ping the MUX and rediscover the SPRT EEPROM.
        \item Device Update \texttt{operator()}: Templated by device driver class. Takes a device FQA and performs \textbf{DLP} to ping the device. Optionally updates the device based on arguments (struct of void pointers) parsed from JSON by the device group's handler function.
        \item \texttt{handleCommand} and \texttt{handleConfig}: Virtual. Ideally, implements custom handling of \texttt{JSONObject} instances to manage and modify module behaviour (i.e. control devices).
    \end{itemize}
\end{itemize}

\subsection{Operational Assumptions}

Assumptions for operation of the I\textsuperscript{2}CIP technology include:
\begin{itemize}
    \item All devices are contained within modules that adhere to the I\textsuperscript{2}CIP hardware specification.
    \item Each module contains a properly formatted SPRT EEPROM with accurate device information.
    \item All SPRT entries contain device IDs that correspond to actual device types for which a corresponding driver exists.
\end{itemize}

\clearpage

\section{Design Requirements}\label{sec:requirements}

\hspace{24pt} 

\clearpage

\section{Design Performance}\label{sec:performance}

\hspace{24pt} 

\clearpage

\section{Design Potential}\label{sec:potential}

% Plug-and-Play:
% Control Systems
% Modular Robotics
% IoT Devices
% Wearable Technology
% Education

\hspace{24pt} 

\clearpage

% % References
\bibliographystyle{IEEEtran}
\bibliography{references}

\end{document}